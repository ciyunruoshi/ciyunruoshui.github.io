<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/ciyunruoshui.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/ciyunruoshui.github.io/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/ciyunruoshui.github.io/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/ciyunruoshui.github.io/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/ciyunruoshui.github.io/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/ciyunruoshui.github.io/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/ciyunruoshui.github.io/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="上一节中提到了Tomcat和Spring的联系，也就是Tomcat在创建ServletContext的时候，通知了在Servlet中注册的ContextListener同时启动了Spring的IOC容器，导致整个Spring启动，那么接下来就是下一步  IOC容器是什么？ IOC与DI怎么实现 jsp和HTML什么关系，为什么会出现jsp  ###IOC容器是什么 正如Servlet有Servle">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat到Spring(2)">
<meta property="og:url" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="上一节中提到了Tomcat和Spring的联系，也就是Tomcat在创建ServletContext的时候，通知了在Servlet中注册的ContextListener同时启动了Spring的IOC容器，导致整个Spring启动，那么接下来就是下一步  IOC容器是什么？ IOC与DI怎么实现 jsp和HTML什么关系，为什么会出现jsp  ###IOC容器是什么 正如Servlet有Servle">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/BeanDefinition.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/relation.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean2.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean3.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean4.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean5.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean6.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean7.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean9.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean10.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean11.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean12.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean13.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean14.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean15.jpg">
<meta property="og:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/Bean16.jpg">
<meta property="og:updated_time" content="2019-07-16T05:38:24.590Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tomcat到Spring(2)">
<meta name="twitter:description" content="上一节中提到了Tomcat和Spring的联系，也就是Tomcat在创建ServletContext的时候，通知了在Servlet中注册的ContextListener同时启动了Spring的IOC容器，导致整个Spring启动，那么接下来就是下一步  IOC容器是什么？ IOC与DI怎么实现 jsp和HTML什么关系，为什么会出现jsp  ###IOC容器是什么 正如Servlet有Servle">
<meta name="twitter:image" content="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/spring/BeanDefinition.jpg">





  
  
  <link rel="canonical" href="https://ciyunruoshi.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Tomcat到Spring(2) | Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/ciyunruoshui.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/ciyunruoshui.github.io/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/ciyunruoshui.github.io/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ciyunruoshi.github.io/ciyunruoshui.github.io/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ciyunroshui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/ciyunruoshui.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Tomcat到Spring(2)

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-13 17:38:17" itemprop="dateCreated datePublished" datetime="2019-07-13T17:38:17+08:00">2019-07-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-16 13:38:24" itemprop="dateModified" datetime="2019-07-16T13:38:24+08:00">2019-07-16</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>上一节中提到了Tomcat和Spring的联系，也就是Tomcat在创建ServletContext的时候，通知了在Servlet中注册的ContextListener同时启动了Spring的IOC容器，导致整个Spring启动，那么接下来就是下一步</p>
<ul>
<li>IOC容器是什么？</li>
<li>IOC与DI怎么实现</li>
<li>jsp和HTML什么关系，为什么会出现jsp</li>
</ul>
<p>###<strong>IOC容器是什么</strong></p>
<p>正如Servlet有ServletContext实现通信和资源共享，那么ServletContext是全部Servlet共享，但是想要范围更小的”局部资源”怎么办，很简单，在构建Servlet容器就好了</p>
<p>于是，Spring也按照这个思路构建了自己的根容器ApplicationContext，也就是IOC容器，那么构建容器可以理解，但是为什么叫IOC呢？</p>
<p>###<strong>IOC的含义</strong></p>
<p>IOC也叫控制反转，是一种编程思想，就是将对象的构建和管理交给第三方（Spring）,需要某个对象或者依赖的时候，就按照一定的逻辑，自动你注入，这也就是DI的原理</p>
<p>这种方式的好处有很多，原来的自己变得程序，需要自己编写入口,main函数，在某个方法中使用对象时候需要自己创建，而且如果想要传给其他方法，就要把这个对象保留，然后以参数的形式传递出去，当然，为什么不把他当作全局变量呢？如果要增加方法，增加变量，那么就要修改已有的代码，增加全局变量，这明显违反了开闭原则。</p>
<p>因此，使用IOC也就是变相的实现了全局变量，而且IOC容器还可以控制这个全局变量的范围，正如上面提到不同范围的容器，这样就可以不修改源代码，但是还可以不断增加”全局变量”。</p>
<p>好了这就是IOC的基本作用，那么我们就用IOC作为切入点来看看spring的底层原理：</p>
<p>###<strong>IOC的bean</strong></p>
<p>为什么叫bean，我也不知道，但是在这里bean等同于符合spring规范的一个对象，而IOC容器正式利用无数的bean和他们的信息文件BeanDefinition,这两者的关系相当于类对象和类的Class对象。<br>也即是说BeanDefinition是用来定义bean的信息。<br>ava说，万物皆对象。但是Spring另外搞了BeanDefinition…</p>
<p>什么BeanDefinition呢？其实它是bean定义的一个顶级接口:</p>
<p><img src="spring/BeanDefinition.jpg" alt="spring"></p>
<p>哎呀卧槽，啥玩意啊。描述一个bean实例？我咋想起了Class类呢。</p>
<p>其实，两者并没有矛盾。</p>
<p><img src="spring/relation.jpg" alt="spring"></p>
<p>Class只是描述了一个类有哪些字段、方法，但是无法描述如何实例化这个bean！如果说，Class类描述了一块猪肉，那么BeanDefinition就是描述如何做红烧肉:</p>
<ul>
<li>单例吗？</li>
<li>是否需要延迟加载？</li>
<li>需要调用哪个初始化方法/销毁方法？</li>
</ul>
<blockquote>
<p>在容器内部，这些bean定义被表示为BeanDefinition对象，包含以下元数据：</p>
</blockquote>
<blockquote>
<p>1.包限定的类名：通常，定义bean的实际实现类。</p>
</blockquote>
<blockquote>
<p>2.Bean行为配置：它声明Bean在容器中的行为(范围、生命周期回调，等等)。</p>
<p>3.Bean依赖：对其他Bean的引用。</p>
<p>4.对当前Bean的一些设置：例如，池的大小限制或在管理连接池的bean中使用的连接数。</p>
<p>——Spring官方文档</p>
</blockquote>
<p>大部分初学者以为Spring解析<bean>或者@Bean后，就直接搞了一个bean存到一个大Map中，其实并不是。</bean></p>
<ul>
<li>Spring首先会扫描解析指定位置的所有的类得到Resources（可以理解为.Class文件）</li>
<li>然后依照TypeFilter和@Conditional注解决定是否将这个类解析为BeanDefinition</li>
<li>稍后再把一个个BeanDefinition取出实例化成Bean</li>
</ul>
<p>就好比什么呢？你从海里吊了一条鱼，但是你还没想好清蒸还是红烧，那就干脆先晒成鱼干吧。一条咸鱼，其实蕴藏着无限可能，因为它可能会翻身！</p>
<p>###<strong>默默付出的后置处理器</strong></p>
<p>接下来，我们讨论一下咸鱼如何翻身。</p>
<p>最典型的例子就是AOP。如果不加@Transactional，那么Controller层注入的就是普通的实现类对象，而加了注解以后返回的实际是代理对象。（下面会谈到）</p>
<p>为什么Spring要返回代理对象？因为我们压根就没在UserServiceImpl中写任何commit或者rollback等事务相关的代码，但是此时此刻代理对象却能完成事务操作。毫无疑问，这个代理对象已经被Spring加了佐料（事务增强代码）。</p>
<p>那么Spring是何时何地加佐料的呢？说来话长，我们先绕个弯子。</p>
<p>大部分人把Spring比作容器，其实潜意识里是将Spring完全等同于一个Map了。其实，真正存单例对象的Map，只是Spring中很小很小的一部分，仅仅是BeanFactory子类的一个字段，我更习惯称它为“单例池”。</p>
<pre><code>/** Cache of singleton objects: bean name --&gt; bean instance */
private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);
</code></pre><p><img src="spring/Bean.jpg" alt="spring"></p>
<p>这里的ApplicationContext和BeanFactory是接口，实际上都有各自的子类。比如注解驱动开发时，Spring中最关键的就是AnnotationConfigApplicationContext和DefaultListableBeanFactory。</p>
<p>所以，很多人把Spring理解成一个大Map，还是太肤浅了。就拿ApplicationContext来讲，它也实现了BeanFactory接口，说明它其实也是一个容器。但是同为容器，与BeanFactory不同的是，ApplicationContext主要用来包含各种各样的组件，而不是存bean</p>
<p><img src="spring/Bean2.jpg" alt="spring"></p>
<p>那么，Spring是如何给咸鱼加佐料（事务代码的织入）的呢？关键就在于后置处理器</p>
<p>后置处理器其实可以分好多种，属于Spring的扩展点之一：</p>
<p><img src="spring/Bean3.jpg" alt="spring"></p>
<p>前三个BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor、BeanPostProcessor都算是后置处理器，这里篇幅有限，暂且先只介绍一下BeanPostProcessor。</p>
<p><img src="spring/Bean4.jpg" alt="spring"><br>BeanFactoryPostProcessor是处理BeanFactory的，所以存在ApplicationContext中。而BeanPostProcessor是处理Bean的，所以存在BeanFactory中，请务必注意！</p>
<p>BeanFactoryPostProcessor是用来干预BeanFactory创建的，而BeanPostProcessor是用来干预Bean的实例化。不知道大家有没有试过在普通Bean中注入ApplicationContext实例？你第一时间想到的是：</p>
<pre><code>@Autowired
ApplicationContext annotationConfigApplicationContext;
</code></pre><p>除了利用Spring本身的IOC容器自动注入以外，你还有别的办法吗？<br>我们可以让Bean实现ApplicationContextAware接口</p>
<p><img src="spring/Bean5.jpg" alt="spring"></p>
<p>实现ApplicationContextAware接口，并实现setApplicationContext()方法，用成员变量去接收形参applicationContext</p>
<p>后期，Spring会调用setApplicationContext()方法传入ApplicationContext实例。</p>
<blockquote>
<p>Spring官方文档：一般来说，您应该避免使用它，因为它将代码耦合到Spring中，并且不遵循控制反转样式。</p>
</blockquote>
<p>这是我认为Spring最牛逼的地方：代码具有高度的可扩展性，甚至你自己都懵逼，为什么实现了一个接口，这个方法就被莫名其妙调用，还传进了一个对象..</p>
<p>这其实就是后置处理器的工作！</p>
<p>什么意思呢？</p>
<p>也就是说，虽然表面上在我们只要让Bean实现一个接口就能完成ApplicationContext组件的注入，看起来很简单，但是背地里Spring做了很多事情。Spring会在框架的某一处搞个for循环，遍历当前容器中所有的BeanPostProcessor，其中就包括一个叫ApplicationContextAwareProcessor的后置处理器，它的作用是：处理实现了ApplicationContextAware接口的Bean。</p>
<p><img src="spring/Bean6.jpg" alt="spring"><br>Spring Bean的生命周期，创建过程必然经过BeanPostProcessor<br>要扩展的类（Bean）是不确定的，但是处理扩展类的流程（循环BeanPostProcessor）是写死的。因为一个程序，再怎么高度可扩展，总有一个要定下来吧。也就是说，在这个Bean实例化的某一紧要处，必然要经过很多BeanPostProcessor。但是，BeanPostProcessor也不是谁都处理，有时也会做判断。比如：</p>
<pre><code>if (bean instanceof Aware) {
    if (bean instanceof EnvironmentAware) {
        ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
    }
    if (bean instanceof EmbeddedValueResolverAware) {
        ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
    }
    if (bean instanceof ResourceLoaderAware) {
        ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
    }
    if (bean instanceof ApplicationEventPublisherAware) {
        ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
    }
    if (bean instanceof MessageSourceAware) {
        ((MessageSourceAware) bean).setMessageSource(this.applicationContext);
    }
    if (bean instanceof ApplicationContextAware) {
        ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
    }
}
</code></pre><p>所以，此时此刻一个类实现ApplicationContextAware接口，有两层含义：</p>
<ul>
<li>作为后置处理器的判断依据，只有你实现了该接口我才处理你</li>
<li>提供被后置处理器调用的方法</li>
</ul>
<p><img src="spring/Bean7.jpg" alt="spring"></p>
<p>####利用后置处理器返回代理对象</p>
<p>大致了解Spring Bean的创建流程后，接下来我们尝试着用BeanPostProcessor返回当前Bean的代理对象。</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
&lt;version&gt;4.3.12.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>AppConfig</p>
<pre><code>@Configuration //JavaConfig方式，即当前配置类相当于一个applicationConotext.xml文件
@ComponentScan //默认扫描当前配置类（AppConfig）所在包及其子包
public class AppConfig {

}
</code></pre><p>Calculator</p>
<pre><code>public interface Calculator {
    public void add(int a, int b);
}
</code></pre><p>CalCulatorImpl</p>
<pre><code>@Component
public class CalculatorImpl implements Calculator {
    public void add(int a, int b) {
        System.out.println(a+b);
    }
}
</code></pre><p>后置处理器MyAspectJAutoProxyCreator<br>使用步骤：</p>
<ol>
<li>实现BeanPostProcessor</li>
<li><p>@Component加入Spring容器</p>
<p> @Component<br> public class MyAspectJAutoProxyCreator implements BeanPostProcessor {</p>
<pre><code>public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    return bean;
}

public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    final Object obj = bean;
    //如果当前经过BeanPostProcessors的Bean是Calculator类型，我们就返回它的代理对象
    if (bean instanceof Calculator) {
       Object proxyObj = Proxy.newProxyInstance(
                this.getClass().getClassLoader(),
                bean.getClass().getInterfaces(),
                new InvocationHandler() {
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println(&quot;开始计算....&quot;);
                        Object result = method.invoke(obj, args);
                        System.out.println(&quot;结束计算...&quot;);
                        return result;
                    }
                }
        );
       return proxyObj;
    }
    //否则返回本身
    return obj;
}
</code></pre><p> }</p>
</li>
</ol>
<pre><code>public class TestPostProcessor {
public static void main(String[] args) {

    System.out.println(&quot;容器启动成功！&quot;);
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);

    String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();
    //打印当前容器所有BeanDefinition
    for (String beanDefinitionName : beanDefinitionNames) {
        System.out.println(beanDefinitionName);
    }

    System.out.println(&quot;============&quot;);

    //取出Calculator类型的实例，调用add方法
    Calculator calculator = (Calculator) applicationContext.getBean(Calculator.class);
    calculator.add(1, 2);
}
</code></pre><p>先把MyAspectJAutoProxyCreator的@Component注释掉，此时Spring中没有我们自定义的后置处理器，那么返回的就是CalculatorImpl：<br><img src="spring/Bean9.jpg" alt="spring"></p>
<p>把@Component加上，此时MyAspectJAutoProxyCreator加入到Spring的BeanPostProcessors中，会拦截到CalculatorImpl，并返回代理对象：</p>
<p><img src="spring/Bean10.jpg" alt="spring"></p>
<p>代理对象的add()方法被增强：前后打印日志</p>
<p>至此，bean被创建，交给IOC容器管理，实现依赖注入</p>
<p>###<strong>依赖注入</strong></p>
<p>依赖注入可以分为两个部分，依赖和注入，上面一部分是关于找到Bean信息，然根据Beandefinination创建Bean,那么如何把我们自己编写的类的依赖告诉IOC容器呢？</p>
<ul>
<li>xml配置文件</li>
<li>注解</li>
</ul>
<p>####1. 配置文件</p>
<p>配置文件的方法很简单，在spring-context.xml中配置所有bean和bean的依赖关系<br>首先，提供一些配置信息（比如XML）来描述类与类之间的关系，然后由IOC容器（Spring Context）去解析这些配置信息，继而维护好对象之间的关系。</p>
<pre><code>&lt;!-- 配置信息：在XML中定义Bean --&gt;
&lt;bean id=&quot;person&quot; class=&quot;com.bravo.annotation.Person&quot;&gt;
    &lt;property name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;


&lt;bean id=&quot;car&quot; class=&quot;com.bravo.annotation.Car&quot;&gt;&lt;/bean&gt;
</code></pre><p>其次，还有一个很重要的前提是，对象之间的依赖关系必须在类中定义好。</p>
<pre><code>public class Person {
    // Person类中声明了Car，表示Person依赖Car
    private Car car;
    // 由于上面XML使用了&lt;property&gt;标签，表示setter方法注入，所以必须提供setter方法
    public void setCar(Car car) {
        this.car = car;
    }
}
</code></pre><p>总结起来就是：</p>
<ul>
<li>编写配置信息描述类与类之间的关系（XML/注解/Configuration配置类均可</li>
<li>对象之间的依赖关系必须在类中定义好（一般是把依赖的对象作为成员变量）</li>
<li>Spring会按照配置信息的指示，通过构造方法或者setter方法完成依赖注入</li>
</ul>
<p>Spring的3种编程风格与2种注入方式</p>
<p>按照Spring官方文档的说法，Spring的容器配置方式可以分为三种：</p>
<ul>
<li>Schema-based Container Configuration（XML配置）</li>
<li>Annotation-based Container Configuration（注解）</li>
<li>Java-based Container Configuration（@Configuration配置类）</li>
</ul>
<p>Spring支持的2种注入方式：</p>
<ul>
<li>构造方法注入</li>
<li>setter方法注入</li>
</ul>
<p>在Spring4之前，Spring还支持接口注入（很少用），这里不提及。</p>
<p>大家必须要明确，所谓3种编程风格和2种注入方式到底指什么，之间又有什么联</p>
<p>我们从2种注入方式开始分析。</p>
<blockquote>
<p>Q：Spring注入的是什么？</p>
<p>A：是Bean。</p>
<p>Q：这些Bean怎么来的？</p>
</blockquote>
<blockquote>
<p>A：IOC容器里的</p>
</blockquote>
<p>所以，所谓的3种编程风格其实指的是“将Bean交给Spring管理的3种方式”，可以理解为IOC，而2种注入方式即DI，是建立在IOC的基础上的。也就是说Spring的DI（依赖注入）其实是以IOC容器为前提。</p>
<p><img src="spring/Bean11.jpg" alt="spring"></p>
<h2 id="1-XML配置开发：描述依赖关系"><a href="#1-XML配置开发：描述依赖关系" class="headerlink" title="1. XML配置开发：描述依赖关系"></a><strong>1. XML配置开发：<bean>描述依赖关系</bean></strong></h2><p>setter方法注入<br>pom.xml</p>
<pre><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre><p>配置信息（setter方法注入）</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;


    &lt;!-- 在xml中描述类与类的配置信息 --&gt;
    &lt;bean id=&quot;person&quot; class=&quot;com.bravo.xml.Person&quot;&gt;
        &lt;!-- property标签表示，让Spring通过setter方法注入--&gt;
        &lt;property name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;


    &lt;bean id=&quot;car&quot; class=&quot;com.bravo.xml.Car&quot;&gt;&lt;/bean&gt;


&lt;/bean

  &apos;}&apos;;
}
</code></pre><p>配置信息（构造方法注入）</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;


    &lt;!-- 在xml中描述类与类的配置信息 --&gt;
    &lt;bean id=&quot;person&quot; class=&quot;com.bravo.xml.Person&quot;&gt;
        &lt;!-- constructor-arg标签表示，让Spring通过构造方法注入--&gt;
        &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;car&quot; class=&quot;com.bravo.xml.Car&quot;&gt;&lt;/bean&gt;

&lt;/beans&gt;
</code></pre><p>至此，我们把XML配置下2种注入方式都实验过了，它们的区别是：</p>
<ul>
<li>XML配置信息的<property> + 对象的setter方法</property></li>
<li>XML配置信息的<constructor-arg> + 对象的构造方法<br>改变XML配置的同时，需要对象提供对应的方法支持。如果你用了<property>，却没有在类中提供setter方法，则会报错。<br>####自动装配：让<bean>职责单一化</bean></property></constructor-arg></li>
</ul>
<p>我们会发现<bean>这个标签，其实承载着两个作用：</bean></p>
<ul>
<li>定义bean，告诉Spring哪个Bean需要交给它管理（放入容器）</li>
<li>维护bean与bean之间的依赖关系<br>接下来我们思考这样一个问题：</li>
</ul>
<p>对于Person类</p>
<pre><code>public class Person {
    // Person依赖Car
    private Car car;


    public void setCar(Car car) {
        this.car = car;
    }
}
</code></pre><p>上面代码其实已经很好地描述了Person和Car的依赖关系，此时在XML中继续用<property>或者<constructor-arg>反而成了累赘</constructor-arg></property></p>
<ul>
<li>既然类结构本身包含了依赖信息，<bean>再用<property>等去描述就显得多余了</property></bean></li>
<li>如果类结构变动，我们还需要额外维护<bean>的依赖信息，很麻烦。比如Person新增了一个shoes字段，那么<bean>又要写一个<property>表示shoes</property></bean></bean></li>
</ul>
<p>所以，最好的做法是把让<bean>标签职责单一化，让它只负责定义bean，把bean与bean的依赖关系转交给类自身维护（有这个字段就说明有依赖）。</bean></p>
<p>既然菜鸡的我们能想到，那么Spring肯定也想到了，于是它提出了“自动装配”的概念。很多人一听到自动装配，脑子里只有@Autowired。不算错，但其实XML也支持自动装配，而且真要论先来后到的话，肯定还是XML的自动装配在前。</p>
<p>XML实现自动装配可以分为两种：全局、局部。</p>
<p>全局自动装配（XML根标签<beans>末尾加default-autowire配置）</beans></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;
        default-autowire=&quot;byName&quot;&gt;


    &lt;!-- 在xml中只定义bean，无需配置依赖关系 --&gt;
    &lt;bean id=&quot;person&quot; class=&quot;com.bravo.xml.Person&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;car&quot; class=&quot;com.bravo.xml.Car&quot;&gt;&lt;/bean&gt;

&lt;/beans&gt;
</code></pre><p>所谓全局，就是在XML根标签末尾再加一个配置default-autowire=”byName”，那么在此XML中配置的每一个<bean>都遵守这个自动装配模式，可选值有4个：</bean></p>
<ul>
<li>byName</li>
<li>byType</li>
<li>constructor</li>
<li>no</li>
</ul>
<p>局部自动装配（每一个<bean>单独设置autowire）</bean></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;


    &lt;!-- 在xml中只定义bean，无需配置依赖关系 --&gt;
    &lt;bean id=&quot;person&quot; class=&quot;com.bravo.xml.Person&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;


    &lt;bean id=&quot;car&quot; class=&quot;com.bravo.xml.Car&quot;&gt;&lt;/bean&gt;


&lt;/bean
</code></pre><p>小结：</p>
<ul>
<li>Spring支持自动装配（全局/局部），把原先<bean>标签的职责单一化，只定义bean，而依赖关系交给类本身维护</bean></li>
<li>自动装配共4种，除了no，其他3种各自对应两种注入方式：byName/byType对应setter方法注入，constructor对应构造方法注入 </li>
</ul>
<h2 id="XML-注解：XML-context-component-scan-Component"><a href="#XML-注解：XML-context-component-scan-Component" class="headerlink" title="XML+注解：XML+context:component-scan+@Component"></a>XML+注解：XML+<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>+@Component</h2><p>原本<bean>标签有两个职责：</bean></p>
<ul>
<li>定义bean</li>
<li>描述依赖信息</li>
</ul>
<p>上面通过自动装配，把依赖信息交给类本身维护，从此<bean>只负责bean定义。</bean></p>
<p>现在，我们想想办法，能不能干脆把bean定义也剥离出来？这样就不需要在XML中写任何<bean>标签了。我早就看<bean>标签不爽了，这么一大坨，要是bean多了，就很臃肿。</bean></bean></p>
<p>怎么做呢？</p>
<p>Spring已经帮我们做了自动装配，也就是说依赖信息和依赖注入已经不需要我们操心。我们接下来要考虑的是，如何把bean定义给到Spring。原先是把<bean>写在XML中，再把XML喂给Spring：</bean></p>
<pre><code>ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-context.xml&quot;);
</code></pre><p>既然现在打算消灭XML中的<bean>，则说明即使把XML喂给Spring，它也吃不到bean定义了。所以，必须要告诉Spring去哪可以吃到bean。</bean></p>
<p>我们来看一下，当Spring吃下<bean>时，到底吃了什么：</bean></p>
<pre><code>&lt;!-- 在xml中只定义bean，无需配置依赖关系 --&gt;
&lt;bean id=&quot;person&quot; class=&quot;com.bravo.xml.Person&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;car&quot; class=&quot;com.bravo.xml.Car&quot;&gt;&lt;/bean&gt;
</code></pre><p>是的，<bean>只指定了类名和自动装配的模式。也就是说，要定义一个bean，只需要最基本的两样东西：</bean></p>
<ul>
<li>类名</li>
<li>装配模式（默认no，不自动装配）</li>
</ul>
<p>而类名其实很好得到，我们自己写的类不就有吗？至于自动装配的模式，也完全可以在类中通过注解指定。于是，我们找到了改造的方向：用带注解的类代替<bean>标签。</bean></p>
<p><img src="spring/Bean12.jpg" alt="spring"></p>
<p>之前：XML中写好bean标签后，把XML喂给Spring，Spring就会把bean实例化加到容器</p>
<p><img src="spring/Bean13.jpg" alt="spring"><br>现在：消灭bean标签后，XML中已经没有bean，Spring必须自己去找bean定义</p>
<p>Spring2.5开始提供了一系列注解，比如@Component、@Service等，这些注解都是用来表示bean的。而@Service等注解底层其实还是@Component<br>之所以做一层封装，是为了赋予它特殊的语义：定义Service层的bean。其余的这里不再赘述。总之我们暂时理解为，如果要使用注解表示bean定义，我们能用的只有@Component。Person</p>
<p>@Component //带注解的类，我们希望用这种方式定义bean，并让Spring把它吃进去</p>
<pre><code>public class Person {


    // Person依赖Car
    private Car car;


    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;car=&quot; + car +
                &apos;}&apos;;
    }
}
</code></pre><p>Car</p>
<pre><code>@Component
public class Car {
}
</code></pre><p>XML（什么都没有配置，连自动装配模式也没指定，因为不在这里定义bean了）</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;


&lt;/beans&gt;
</code></pre><p>Test</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        // 由于是XML配置方式，对应的Spring容器是ClassPathXmlApplicationContext,传入配置文件告知Spring去哪读取配置信息
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-context.xml&quot;);
        // 从容器中获取Person
        Person person = (Person) applicationContext.getBean(&quot;person&quot;);
        System.out.println(person);
    }
}
</code></pre><p><img src="spring/Bean14.jpg" alt="spring"></p>
<p>在Spring容器中找不到person</p>
<p>其实很好理解，我们传入了spring-context.xml告诉Spring去哪读取bean定义，但是实际上XML却没有配置任何<bean>，它是不可能把类实例化加入到容器的。</bean></p>
<p>然而我们新定义的bean（@Component）Spring也没吃，怎么回事？</p>
<p>其实主要是因为我们的改变太突然了，Spring以前吃惯了XML中的<bean>，现在突然换成@Component这种注解类，它吃不惯，甚至不知道它能吃！</bean></p>
<p>所以，必须通知Spring</p>
<blockquote>
<p>老哥，我们改用注解了，有@Component注解的类就是bean，和以前<bean>一样一样的</bean></p>
</blockquote>
<p>如何通知？只要在XML中配置：</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.bravo.annotation&quot;/&gt;
</code></pre><p>这个标签的作用相当于什么呢？Spring一口吃下去，发现没有吃到<bean>，却吃出了一张小纸条，上面写着：赶紧去找标了@Component注解的类，那是新菜式！</bean></p>
<p>所以，最终&lt;/context:component-scan&gt;标签的作用有两个：</p>
<ul>
<li>原先我们把写有bean定义的XML文件喂给Spring，现在则让Spring自己去指定路径下扫描bean定义</li>
<li>让Spring具备解析注解的功能</li>
</ul>
<p>所以，XML虽然不用配置<bean>标签，却要配置扫描（需要配置额外的名称空间）：</bean></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;


    &lt;context:component-scan base-package=&quot;com.bravo.annotation&quot;/&gt;


&lt;/beans&gt;
</code></pre><p><img src="spring/Bean15.jpg" alt="spring"></p>
<p>又出幺蛾子了，怎么回事呢？我们回想一下XML的bean定义：</p>
<pre><code>&lt;!-- 在xml中只定义bean，无需配置依赖关系 --&gt;
&lt;bean id=&quot;person&quot; class=&quot;com.bravo.xml.Person&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;car&quot; class=&quot;com.bravo.xml.Car&quot;&gt;&lt;/bean&gt;
</code></pre><p>我们设置了autowire属性，告诉Spring按什么方式自动装配。</p>
<p>现在我们改用注解了，@Component只是相当于<bean>标签，却没有指明自动装配的模式。如何在类中告诉Spring我们需要的装配方式呢？</bean></p>
<p>方法有很多种：</p>
<ul>
<li>@Autowired（Spring提供的） 默认byType，type相同则byName</li>
<li>@Resource（JSR-250定义）和@Autowired几乎一样，但不能配合@Qualifier，因为它本身就可以指定</li>
<li>@Inject（JSR-330定义）用的很少，不做讨论</li>
</ul>
<h2 id="JavaConfig-注解"><a href="#JavaConfig-注解" class="headerlink" title="JavaConfig+注解"></a>JavaConfig+注解</h2><p>解的使用必须包含三步：定义注解、使用注解、解析注解。@Component是Spring定义、我们使用，也肯定是由Spring解析。但是这个解析必须由我们手动开启。这就是<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>标签的意义。</p>
<p>到了这一步我们已经把<bean>标签完全消灭了。但是这种模式有点不伦不类。</bean></p>
<p>你说它叫XML配置开发吧，它又有@Component注解。你说它是注解开发吧，XML中还有一个<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>在那嘚瑟呢。所以如何才能完全消灭XML呢？</p>
<p>究其根本，我们发现无法消灭XML的原因在于：注解的读取和解析必须依赖于<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>标签！因为我们要帮Spring开启注解扫描，不然他不知道去哪读取bean。</p>
<p>既然<bean>标签可以被@Component代替，那么<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>标签应该也能找到对应的注解。</bean></p>
<p>不错！这个注解就是@ComponentScan！如此一来我们就再也不需要spring-context.xml了。</p>
<p>但是转念一想，脊背发凉…ClassPathXmlApplicationContext这个类要求我们必须传一个XML，怎么办？别担心，Spring同样提供了一个注解@Configuration，目的是让我们可以把一个普通的Java类等同于一个XML文件，而这个Java类就是JavaConfig，我们习惯称之为配置类。</p>
<pre><code>@Configuration //表示这个Java类充当XML配置文件
@ComponentScan(basePackages = &quot;com.bravo.javaconfig&quot;) //相当于XML中的&lt;context:component-scan&gt;标签
public class AppConfig {


}
</code></pre><p>这样，我们就可以把XML删除，用@ComponentScan来开启注解扫描。</p>
<p><img src="spring/Bean16.jpg" alt="spring"></p>
<p>ClassPathXmlApplicationContext无法接受AppConfig配置类，它只认XML</p>
<p>所以，用AppConfig配置类替代XML只是我们的一厢情愿吗？</p>
<p>其实是我们选错了实现类。ApplicationContext的子类除了ClassPathXmlApplicationContext，还有一个专门针对注解开发的：AnnotationConfigApplicationContext。</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext是Spring用来专门针对注解开发的ApplicationContext子类
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        // 从容器中获取Person
        Person person = (Person) applicationContext.getBean(&quot;person&quot;);
        System.out.println(person);
    }
}
</code></pre><p>至此，XML已经被我们完全消灭了。</p>
<h2 id="JavaConfig方式：-Configuration-Bean"><a href="#JavaConfig方式：-Configuration-Bean" class="headerlink" title="JavaConfig方式：@Configuration+@Bean"></a>JavaConfig方式：@Configuration+@Bean</h2><p>严格来说，上面的做法并不是所谓的Java-based Container Configuration（@Configuration配置类）风格。我们虽然用到了@Configuration，但只是为了让Java配置类替代XML，最终消灭XML。这也太大材小用了…本质上，这还是@Component+@Autowired注解开发，只是开启注解扫描的方式从<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>标签变为@ComponentScan。</p>
<p>实际上，真正的Java-based Container Configuration编程风格是这样的：</p>
<p>AppConfig（如果你不使用@Component，则不需要@ComponentScan）</p>
<pre><code>@Configuration
public class AppConfig {

    //new一个Benz对象，通过@Bean注解告知Spring把这个bean加到容器
    @Bean
    public Car benz(){
       return new Benz();
    }

    //new一个Bmw对象，通过@Bean注解告知Spring把这个bean加到容器
    @Bean
    public Car bmw(){
        return new Bmw();
    }

    //new一个Person对象，通过@Bean注解告知Spring把这个bean加到容器
    @Bean
    public Person person(){
        Person p = new Person();
        p.setCar(new Benz());
        return p;
    }

}
</code></pre><p>Benz（去除@Component，那是注解开发方式）</p>
<pre><code>public class Benz implements Car {
}
</code></pre><p>Bmw（去除@Component，那是注解开发方式）</p>
<pre><code>public class Bmw implements Car {
}
</code></pre><p>Person（去除@Component，那是注解开发方式）</p>
<pre><code>public class Person {

    private Car car;

    // setter方法
    public void setCar(Car car) {
        this.car = car;
        System.out.println(&quot;通过setter方法注入...&quot;);
    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;car=&quot; + car +
                &apos;}&apos;;
    }
}
</code></pre><p>小结</p>
<p>Java-based Container Configuration编程风格指的是：</p>
<ul>
<li>用@Configuration把一个普通Java类变成配置类，充当XML<br>在配置类中写多个方法，加上@Bean把返回值对象加到Spring容器中</li>
<li>把配置类AppConfig喂给AnnotationConfigApplicationContext，让它像解析XML一样解析配置类</li>
<li>无需加@Component注解，因为我们可以手动new之后通过@Bean加入容器</li>
</ul>
<p>小结</p>
<ul>
<li>纯XML配置开发：没有注解，全部<bean>标签，但也可以配置自动装配</bean></li>
<li>注解开发不能单独存在，需要开启。自动装配一般用@Autowired，默认byType</li>
<li>XML+注解：XML+<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>+@Component</li>
<li>JavaConfig+注解：@Configuration+@ComponentScan+@Component</li>
<li>JavaConfig方式：@Configuration+@Bean<br>通常我们都会两两混用，比如XML+注解，或者JavaConfig+注解，但很少三种一起用。</li>
</ul>
<p>3种编程风格：XML、注解、JavaConfig<br>2种注入方式：setter方法、构造方法<br>4种装配模式：byType、byName、constructor、no</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/ciyunruoshui.github.io/2019/07/13/Tomcat-Spring/" rel="next" title="Tomcat+Spring">
                <i class="fa fa-chevron-left"></i> Tomcat+Spring
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ciyunroshui</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/ciyunruoshui.github.io/archives/">
                
                    <span class="site-state-item-count">66</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-XML配置开发：描述依赖关系"><span class="nav-number">1.</span> <span class="nav-text">1. XML配置开发：描述依赖关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XML-注解：XML-context-component-scan-Component"><span class="nav-number">2.</span> <span class="nav-text">XML+注解：XML+context:component-scan+@Component</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaConfig-注解"><span class="nav-number">3.</span> <span class="nav-text">JavaConfig+注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaConfig方式：-Configuration-Bean"><span class="nav-number">4.</span> <span class="nav-text">JavaConfig方式：@Configuration+@Bean</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ciyunroshui</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/ciyunruoshui.github.io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/ciyunruoshui.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/ciyunruoshui.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/ciyunruoshui.github.io/js/src/utils.js?v=7.0.1"></script>

  <script src="/ciyunruoshui.github.io/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/ciyunruoshui.github.io/js/src/affix.js?v=7.0.1"></script>

  <script src="/ciyunruoshui.github.io/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/ciyunruoshui.github.io/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/ciyunruoshui.github.io/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/ciyunruoshui.github.io/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
